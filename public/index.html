<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Space Rocket Racer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0b0d17; color: white; font-family: sans-serif; }
        canvas { display: block; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; justify-content: center; align-items: center; }
        .menu-box { pointer-events: auto; background: rgba(20,20,30,0.9); padding: 30px; border: 2px solid #00d2ff; text-align: center; border-radius: 10px; display: none; }
        .visible { display: block; }
        button { background: #00d2ff; border: none; padding: 10px 20px; color: #000; font-weight: bold; cursor: pointer; margin: 5px; font-size: 16px; }
        button:hover { background: #fff; }
        input { padding: 10px; font-size: 16px; text-transform: uppercase; }
        .hud { position: absolute; top: 10px; left: 10px; font-size: 20px; font-weight: bold; color: #00d2ff; pointer-events: none; }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div class="hud">
    Points: <span id="scoreDisplay">0</span> | 
    Speed Lvl: <span id="speedLvl">1</span> | 
    Handle Lvl: <span id="handleLvl">1</span>
</div>

<div id="ui">
    <div id="mainMenu" class="menu-box visible">
        <h1>ROCKET RACER</h1>
        <button onclick="setupSinglePlayer()">Single Player</button>
        <button onclick="showMenu('multiplayerMenu')">Multiplayer</button>
        <button onclick="showMenu('shopMenu')">Upgrade Shop</button>
    </div>

    <div id="multiplayerMenu" class="menu-box">
        <h2>Multiplayer</h2>
        <button onclick="createRoom()">Create Room</button>
        <br><br>
        <input id="roomCodeInput" placeholder="Enter Code">
        <button onclick="joinRoom()">Join</button>
        <br><br>
        <button onclick="showMenu('mainMenu')">Back</button>
    </div>

    <div id="lobbyMenu" class="menu-box">
        <h2>Room: <span id="lobbyCode"></span></h2>
        <p>Waiting for host to start...</p>
        <div id="playerList"></div>
        <button id="startBtn" style="display:none;" onclick="requestStart()">START RACE</button>
    </div>

    <div id="shopMenu" class="menu-box">
        <h2>Upgrade Hangar</h2>
        <p>Current Points: <span id="shopPoints">0</span></p>
        <button onclick="buyUpgrade('speed')">Upgrade Speed (100 pts)</button>
        <button onclick="buyUpgrade('handling')">Upgrade Handling (100 pts)</button>
        <br><br>
        <button onclick="showMenu('mainMenu')">Back</button>
    </div>

    <div id="gameOverMenu" class="menu-box">
        <h1>FINISHED!</h1>
        <h2 id="resultText"></h2>
        <p>Points Earned: <span id="earnedPoints">0</span></p>
        <button onclick="showMenu('mainMenu')">Main Menu</button>
    </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const socket = io();

    // Game State
    let width, height;
    let gameState = 'menu'; // menu, lobby, playing
    let roomCode = null;
    let isHost = false;
    let opponents = {}; // Stores opponent {x, y, angle}
    
    // Player Stats (Persisted)
    let stats = {
        points: parseInt(localStorage.getItem('rr_points')) || 0,
        speedLvl: parseInt(localStorage.getItem('rr_speed')) || 1,
        handleLvl: parseInt(localStorage.getItem('rr_handle')) || 1
    };

    // Physics Variables
    let player = {
        x: 0, y: 0,
        vx: 0, vy: 0,
        angle: 0,
        currentPlanetIndex: 0
    };

    let track = [];
    let mouse = { x: 0, y: 0 };
    let camera = { x: 0, y: 0 };

    // --- SETUP & LOOP ---
    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    window.addEventListener('mousemove', e => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    });

    function updateUI() {
        document.getElementById('scoreDisplay').innerText = stats.points;
        document.getElementById('shopPoints').innerText = stats.points;
        document.getElementById('speedLvl').innerText = stats.speedLvl;
        document.getElementById('handleLvl').innerText = stats.handleLvl;
    }
    updateUI();

    function gameLoop() {
        ctx.fillStyle = '#0b0d17';
        ctx.fillRect(0, 0, width, height);

        if (gameState === 'playing') {
            updatePhysics();
            drawGame();
            
            // Multiplayer Sync
            if(roomCode) {
                socket.emit('playerMove', { 
                    room: roomCode, 
                    x: player.x, 
                    y: player.y, 
                    angle: player.angle 
                });
            }
        }

        requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);

    // --- GAME LOGIC ---

    function updatePhysics() {
        // Max speed based on level
        const maxSpeed = 5 + (stats.speedLvl * 1.5);
        const handling = 0.02 + (stats.handleLvl * 0.005);
        const acceleration = 0.2;

        // 1. Calculate Angle to Mouse (relative to camera)
        // Since camera centers on player, mouse relative to center screen
        let dx = mouse.x - (width/2);
        let dy = mouse.y - (height/2);
        let targetAngle = Math.atan2(dy, dx);

        // Smooth Rotation
        let diff = targetAngle - player.angle;
        // Normalize angle difference
        while (diff < -Math.PI) diff += Math.PI * 2;
        while (diff > Math.PI) diff -= Math.PI * 2;
        player.angle += diff * handling;

        // 2. Move Forward
        player.vx += Math.cos(player.angle) * acceleration;
        player.vy += Math.sin(player.angle) * acceleration;

        // Friction/Drag
        player.vx *= 0.98;
        player.vy *= 0.98;

        // Cap speed
        let speed = Math.sqrt(player.vx*player.vx + player.vy*player.vy);
        if (speed > maxSpeed) {
            let ratio = maxSpeed / speed;
            player.vx *= ratio;
            player.vy *= ratio;
        }

        player.x += player.vx;
        player.y += player.vy;

        // 3. Camera Follow
        camera.x = player.x - width/2;
        camera.y = player.y - height/2;

        // 4. Check Checkpoints
        if (track.length > 0) {
            let target = track[player.currentPlanetIndex];
            let dist = Math.hypot(player.x - target.x, player.y - target.y);
            
            if (dist < target.radius + 20) {
                // Reached planet
                if (player.currentPlanetIndex < track.length - 1) {
                    player.currentPlanetIndex++;
                } else {
                    finishRace();
                }
            }
        }
    }

    function drawGame() {
        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        // Draw Stars (Static background relative to world)
        ctx.fillStyle = 'white';
        for(let i=0; i<100; i++) {
            // Simple parallax hack or just random dots fixed in world space
            ctx.fillRect(((i*137)%2000 + player.x*0.1), ((i*94)%2000 + player.y*0.1), 2, 2);
        }

        // Draw Track (Planets)
        track.forEach((p, index) => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
            
            // Highlight Target
            if(index === player.currentPlanetIndex) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 5;
                ctx.stroke();
            }
            if(p.isFinish) {
                ctx.fillStyle = 'white';
                ctx.fillText("FINISH", p.x - 20, p.y);
            }
        });

        // Draw Opponents (Ghosts)
        for (let id in opponents) {
            if(id === socket.id) continue;
            let op = opponents[id];
            drawRocket(op.x, op.y, op.angle, '#ff4444');
        }

        // Draw Player
        drawRocket(player.x, player.y, player.angle, '#00d2ff');

        // Draw Arrow to next planet
        if(track[player.currentPlanetIndex]) {
            let t = track[player.currentPlanetIndex];
            let a = Math.atan2(t.y - player.y, t.x - player.x);
            let arrowDist = 100;
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(player.x + Math.cos(a)*arrowDist, player.y + Math.sin(a)*arrowDist, 5, 0, Math.PI*2);
            ctx.fill();
        }

        ctx.restore();
    }

    function drawRocket(x, y, angle, color) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        
        ctx.fillStyle = color;
        // Simple Triangle Rocket
        ctx.beginPath();
        ctx.moveTo(20, 0);
        ctx.lineTo(-15, 10);
        ctx.lineTo(-15, -10);
        ctx.fill();
        
        // Engine flame
        ctx.fillStyle = 'orange';
        ctx.beginPath();
        ctx.moveTo(-15, 5);
        ctx.lineTo(-30 + Math.random()*10, 0);
        ctx.lineTo(-15, -5);
        ctx.fill();

        ctx.restore();
    }

    // --- MENUS & HELPERS ---

    function showMenu(id) {
        document.querySelectorAll('.menu-box').forEach(el => el.classList.remove('visible'));
        if(id) document.getElementById(id).classList.add('visible');
    }

    function setupSinglePlayer() {
        // Generate a local track
        track = [];
        let startX = 400, startY = 300;
        for (let i = 0; i < 10; i++) {
            track.push({
                x: startX, y: startY,
                radius: 40, color: '#444', isFinish: i===9
            });
            startX += (Math.random() - 0.5) * 800;
            startY -= 400;
        }
        startGame(track);
    }

    function startGame(trackData) {
        track = trackData;
        player.x = track[0].x;
        player.y = track[0].y;
        player.vx = 0; player.vy = 0;
        player.currentPlanetIndex = 1;
        gameState = 'playing';
        showMenu(null); // Hide all menus
    }

    function finishRace() {
        gameState = 'finished';
        if (roomCode) {
            socket.emit('playerFinished', roomCode);
        } else {
            // Single player always gets 1st place points
            endGameScreen(1);
        }
    }

    function endGameScreen(rank) {
        let earned = 0;
        if(rank === 1) earned = 200;
        else if(rank === 2) earned = 100;
        else earned = 50;

        stats.points += earned;
        saveStats();
        
        document.getElementById('resultText').innerText = rank + (rank===1?"st":rank===2?"nd":"th") + " Place!";
        document.getElementById('earnedPoints').innerText = earned;
        showMenu('gameOverMenu');
        
        roomCode = null; // Reset multiplayer
    }

    function buyUpgrade(type) {
        if(stats.points >= 100) {
            stats.points -= 100;
            if(type === 'speed') stats.speedLvl++;
            if(type === 'handling') stats.handleLvl++;
            saveStats();
            updateUI();
        } else {
            alert("Not enough points!");
        }
    }

    function saveStats() {
        localStorage.setItem('rr_points', stats.points);
        localStorage.setItem('rr_speed', stats.speedLvl);
        localStorage.setItem('rr_handle', stats.handleLvl);
        updateUI();
    }

    // --- MULTIPLAYER SOCKETS ---

    function createRoom() {
        socket.emit('createRoom');
    }

    function joinRoom() {
        const code = document.getElementById('roomCodeInput').value.toUpperCase();
        socket.emit('joinRoom', code);
    }

    function requestStart() {
        if(roomCode && isHost) socket.emit('startGame', roomCode);
    }

    socket.on('roomCreated', (code) => {
        roomCode = code;
        isHost = true;
        document.getElementById('lobbyCode').innerText = code;
        document.getElementById('startBtn').style.display = 'inline-block';
        showMenu('lobbyMenu');
    });

    socket.on('roomJoined', (data) => {
        roomCode = data.code;
        isHost = false;
        track = data.track; // Pre-load track
        document.getElementById('lobbyCode').innerText = data.code;
        document.getElementById('startBtn').style.display = 'none';
        showMenu('lobbyMenu');
    });

    socket.on('updateLobby', (players) => {
        const list = document.getElementById('playerList');
        list.innerHTML = Object.keys(players).map(id => `<div>Player ${id.substr(0,4)}</div>`).join('');
    });

    socket.on('gameStart', (serverTrack) => {
        startGame(serverTrack);
    });

    socket.on('playerMoved', (data) => {
        opponents[data.id] = data;
    });

    socket.on('gameOver', (rank) => {
        if(gameState === 'finished') { // Only trigger if I locally finished
             endGameScreen(rank);
        }
    });

    socket.on('errorMsg', (msg) => alert(msg));

</script>
</body>
</html>
