<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Stellar Drift: Hangar Update</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050508; color: white; font-family: 'Segoe UI', monospace; user-select: none; }
        canvas { display: block; }
        
        /* LAYERS */
        #ui, #hud-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .menu-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; pointer-events: none; z-index: 20; }
        
        /* BIG MAP */
        #bigMapOverlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(5, 10, 20, 0.95); z-index: 150; display: none; 
            pointer-events: auto; backdrop-filter: blur(5px);
        }
        #bigMapContainer { position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .map-header { position: absolute; top: 20px; color: #00d2ff; font-size: 24px; font-weight: bold; pointer-events: none; }
        .map-instr { position: absolute; bottom: 30px; color: #aaa; font-size: 14px; pointer-events: none; }

        /* MENUS */
        .menu-box { pointer-events: auto; background: rgba(16, 20, 35, 0.98); padding: 30px; border: 2px solid #00d2ff; text-align: center; border-radius: 12px; display: none; box-shadow: 0 0 30px rgba(0, 210, 255, 0.2); min-width: 350px; max-height: 80vh; overflow-y: auto; }
        .visible { display: block; }

        h1 { color: #00d2ff; text-transform: uppercase; margin-top: 0; letter-spacing: 2px; font-style: italic; }
        h2 { color: #fff; border-bottom: 1px solid #333; padding-bottom: 10px; }
        
        button { background: linear-gradient(45deg, #00d2ff, #0078ff); border: none; padding: 10px 20px; color: #fff; font-weight: bold; cursor: pointer; margin: 5px; font-size: 14px; border-radius: 4px; text-transform: uppercase; transition: 0.2s; }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0, 210, 255, 0.4); }
        button:disabled { background: #333; color: #555; cursor: not-allowed; transform: none; box-shadow: none; }
        button.secondary { background: #333; color: #aaa; }
        button.gold { background: linear-gradient(45deg, #ffd700, #ffaa00); color: black; }
        button.purple { background: linear-gradient(45deg, #aa00ff, #5500ff); color: white; }
        
        input { padding: 10px; font-size: 14px; background: #050510; color: #fff; border: 1px solid #444; text-align: center; width: 200px; }

        /* HUD */
        .hud-stats { position: absolute; top: 20px; left: 20px; font-size: 16px; font-weight: bold; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.8); pointer-events: none; }
        .ability-cd { margin-top: 5px; font-size: 14px; color: #aaa; }
        .ability-ready { color: #00ff00; text-shadow: 0 0 5px #00ff00; }
        .ability-active { color: #00ffff; text-shadow: 0 0 10px #00ffff; }

        #chatContainer { position: absolute; bottom: 80px; left: 20px; width: 300px; pointer-events: auto; z-index: 100; display: none; }
        #chatMessages { height: 150px; overflow-y: auto; background: rgba(0,0,0,0.6); border: 1px solid #444; padding: 10px; list-style: none; margin: 0; color: #ddd; font-size: 13px; }
        #chatInput { width: 100%; box-sizing: border-box; margin-top: 5px; text-align: left; background: rgba(0,0,0,0.8); }

        /* HANGAR CARDS */
        .ship-card { 
            display: inline-block; width: 100px; height: 140px; 
            background: #111; border: 1px solid #444; margin: 5px; 
            border-radius: 8px; vertical-align: top; position: relative; cursor: pointer;
        }
        .ship-card.unlocked { border-color: #00d2ff; background: #0a1520; }
        .ship-card.selected { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; transform: scale(1.05); }
        .card-title { font-size: 12px; font-weight: bold; margin-top: 10px; color: #fff; }
        .card-count { position: absolute; bottom: 10px; right: 10px; font-size: 18px; color: #aaa; }
        .progress-bar { width: 80%; height: 4px; background: #333; margin: 5px auto; border-radius: 2px; }
        .progress-fill { height: 100%; background: #00d2ff; width: 0%; }

        /* LOOT BOX ANIMATION */
        #lootOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 200; display: none; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        .loot-box-visual { width: 100px; height: 100px; background: gold; animation: shake 0.5s infinite; margin-bottom: 20px; box-shadow: 0 0 50px gold; }
        @keyframes shake { 0% { transform: rotate(0deg); } 25% { transform: rotate(5deg); } 75% { transform: rotate(-5deg); } 100% { transform: rotate(0deg); } }
        .card-reveal { font-size: 24px; color: #00d2ff; margin: 10px; opacity: 0; transform: translateY(20px); transition: 0.5s; }
        .card-reveal.show { opacity: 1; transform: translateY(0); }

    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="bigMapOverlay">
    <div id="bigMapContainer">
        <div class="map-header">TACTICAL MAP</div>
        <canvas id="bigMapCanvas"></canvas>
        <div class="map-instr">CLICK to Set Waypoint | Press [M] to Close</div>
    </div>
</div>

<div id="lootOverlay">
    <div id="lootBoxAnim" class="loot-box-visual"></div>
    <h1 id="lootTitle">OPENING...</h1>
    <div id="lootResults"></div>
    <button id="lootCloseBtn" onclick="closeLoot()" style="display:none; margin-top:20px;">CONTINUE</button>
</div>

<div id="hud-layer">
    <div class="hud-stats">
        <div>POINTS: <span id="scoreDisplay" style="color:#00d2ff">0</span></div>
        <div>SHIP: <span id="currentShipName" style="color:#ffd700">NITRO</span></div>
        
        <div class="ability-cd" id="qAbilityUI">[Q] NITRO: <span id="qCooldown">READY</span></div>
        <div class="ability-cd" id="rAbilityUI">[R] -- : <span id="rCooldown">LOCKED</span></div>

        <div class="coord-box">POS: <span id="coordDisplay">0, 0</span></div>
        <div class="speed-box">VEL: <span id="speedDisplay">0</span></div>
        <div id="chargeUI" style="display:none; color:cyan; font-style:italic;">IMPULSE CHARGE: <span id="chargeVal">0x</span></div>
    </div>

    <div id="chatContainer">
        <ul id="chatMessages"><li style="color:yellow">System: Chat Initialized...</li></ul>
        <input id="chatInput" type="text" placeholder="Press Enter to Chat...">
    </div>

    <div id="buildToolbar" style="position:absolute; bottom:20px; left:50%; transform:translateX(-50%); display:none; pointer-events:auto; background:rgba(0,0,0,0.8); padding:10px; border-radius:8px;">
        <button class="secondary" onclick="setBuildTool(0)">OFF</button>
        <button class="secondary" onclick="setBuildTool(1)">WALL</button>
        <button class="secondary" onclick="setBuildTool(2)">BARRIER</button>
        <button class="secondary" onclick="setBuildTool(3)">CRATE</button>
    </div>

    <div style="position:absolute; bottom:20px; right:20px; width:200px; height:200px; border-radius:50%; overflow:hidden; border:2px solid #00d2ff; background:#001;">
        <canvas id="minimapCanvas" width="200" height="200"></canvas>
    </div>
</div>

<div class="menu-layer">
    <div id="mainMenu" class="menu-box visible">
        <h1>Stellar Drift</h1>
        <p>Hangar & Merging Update</p>
        <button onclick="setupSinglePlayer()">Single Player</button>
        <button onclick="showMenu('multiplayerMenu')">Multiplayer</button>
        <br>
        <button class="purple" onclick="openHangar()">HANGAR & LOOT</button>
        <br>
        <button class="gold" onclick="findOpenWorldGame()">OPEN WORLD ONLINE</button>
        <div style="margin-top:10px; font-size:12px; color:#aaa;">Free Box in: <span id="timerDisplay">00:00</span></div>
    </div>

    <div id="hangarMenu" class="menu-box" style="width:600px;">
        <h2>SHIP HANGAR</h2>
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
            <div>Points: <span id="hangarPoints" style="color:#00d2ff">0</span></div>
            <button class="gold" onclick="buyLootBox()">Buy Box (1000pts)</button>
            <button id="freeBoxBtn" class="purple" onclick="claimFreeBox()" disabled>Free Box</button>
        </div>
        
        <div id="cardContainer" style="text-align:left; margin-bottom:20px; padding-bottom:20px; border-bottom:1px solid #333;">
            </div>

        <h3>MERGE STATION</h3>
        <p style="font-size:12px; color:#aaa;">Select two unlocked ships to merge abilities.</p>
        <div style="display:flex; justify-content:center; gap:20px; align-items:center;">
            <div id="slot1" style="border:1px dashed #555; width:100px; height:100px; line-height:100px; color:#555;">[Q] Primary</div>
            <div style="font-size:20px;">+</div>
            <div id="slot2" style="border:1px dashed #555; width:100px; height:100px; line-height:100px; color:#555;">[R] Secondary</div>
        </div>
        <br>
        <button id="equipBtn" onclick="equipCurrentSelection()">EQUIP CONFIGURATION</button>
        <br><br>
        <button class="secondary" onclick="showMenu('mainMenu')">Back</button>
    </div>

    <div id="multiplayerMenu" class="menu-box">
        <h2>Multiplayer</h2>
        <button onclick="createRoom('race')">Create Race</button><br>
        <input id="roomCodeInput" placeholder="Room Code">
        <button onclick="joinRoom()">Join</button><br>
        <button class="secondary" onclick="showMenu('mainMenu')">Back</button>
    </div>

    <div id="crashMenu" class="menu-box">
        <h1 style="color:#ff3333">WASTED</h1>
        <p id="crashReason">System Failure</p>
        <button onclick="respawnPlayer()">Reassemble</button>
        <button class="secondary" onclick="showMenu('mainMenu')">Quit</button>
    </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
    // --- GLOBAL SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const mmCanvas = document.getElementById('minimapCanvas');
    const mmCtx = mmCanvas.getContext('2d');
    const bmCanvas = document.getElementById('bigMapCanvas');
    const bmCtx = bmCanvas.getContext('2d');
    const socket = io();

    let width, height;
    function resize() { 
        width = canvas.width = window.innerWidth; 
        height = canvas.height = window.innerHeight; 
        bmCanvas.width = window.innerWidth * 0.9;
        bmCanvas.height = window.innerHeight * 0.8;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- GAME STATE ---
    let gameState = 'menu'; // menu, playing, openworld
    let gameMode = 'race';
    let roomCode = null;
    let isBigMapOpen = false;
    let camera = { x:0, y:0, zoom:1 };
    
    // --- SHIP DEFINITIONS ---
    const SHIPS = {
        nitro: { name: "Nitro", color: "#00d2ff", desc: "Q: Speed Boost", ability: "nitro" },
        shadow: { name: "Shadow", color: "#444444", desc: "Q: Phase Walls (5s)", ability: "phase" },
        vision: { name: "Vision", color: "#ff00ff", desc: "Q: Jam Controls", ability: "jam" },
        dasher: { name: "Dasher", color: "#ffff00", desc: "Q: Instant Dash", ability: "dash" }
    };

    // --- PERSISTENCE & ECONOMY ---
    let userState = JSON.parse(localStorage.getItem('drift_user')) || {
        points: 0,
        cards: { nitro: 10, shadow: 0, vision: 0, dasher: 0 }, // Start with Nitro unlocked
        lastFreeBox: 0,
        equipped: { primary: 'nitro', secondary: null }
    };

    function saveState() {
        localStorage.setItem('drift_user', JSON.stringify(userState));
        updateHangarUI();
    }

    // --- PLAYER OBJECT ---
    let player = {
        x:0, y:0, vx:0, vy:0, angle:0, dead:false,
        // Abilities
        primary: 'nitro', secondary: null,
        cooldowns: { q: 0, r: 0 },
        durations: { q: 0, r: 0 }, // For active effects
        // Status Effects
        isPhasing: false,
        controlsInverted: false,
        invertTimer: 0
    };

    let keys = { w:false, a:false, s:false, d:false, shift:false, q:false, r:false };
    let waypoint = null;
    let opponents = {};
    let bots = [];
    let walls = [], track = [], hazards = [], particles = [];

    // --- INPUTS ---
    window.addEventListener('keydown', e => {
        if(document.activeElement.tagName === 'INPUT') return;
        if(e.key === 'w' || e.key === 'ArrowUp') keys.w = true;
        if(e.key === 's' || e.key === 'ArrowDown') keys.s = true;
        if(e.key === 'a' || e.key === 'ArrowLeft') keys.a = true;
        if(e.key === 'd' || e.key === 'ArrowRight') keys.d = true;
        if(e.key === 'q') triggerAbility('q');
        if(e.key === 'r') triggerAbility('r');
        if(e.key === 'm') { isBigMapOpen = !isBigMapOpen; document.getElementById('bigMapOverlay').style.display = isBigMapOpen?'block':'none'; }
    });

    window.addEventListener('keyup', e => {
        if(e.key === 'w' || e.key === 'ArrowUp') keys.w = false;
        if(e.key === 's' || e.key === 'ArrowDown') keys.s = false;
        if(e.key === 'a' || e.key === 'ArrowLeft') keys.a = false;
        if(e.key === 'd' || e.key === 'ArrowRight') keys.d = false;
    });
    
    // Mouse for Map/Build
    let mouseX=0, mouseY=0;
    window.addEventListener('mousemove', e => { mouseX=e.clientX; mouseY=e.clientY; });
    window.addEventListener('mousedown', e => {
        if(isBigMapOpen) {
            const rect = bmCanvas.getBoundingClientRect();
            let scale = 0.05; 
            let wx = (e.clientX - rect.left - bmCanvas.width/2)/scale + player.x;
            let wy = (e.clientY - rect.top - bmCanvas.height/2)/scale + player.y;
            waypoint = {x:wx, y:wy};
        }
    });

    // --- ABILITY LOGIC ---
    function triggerAbility(slot) {
        if(player.dead) return;
        let type = slot === 'q' ? player.primary : player.secondary;
        if(!type) return; // No ship in slot
        if(player.cooldowns[slot] > 0) return; // Cooldown active

        // Activate
        let abilityName = SHIPS[type].ability;
        let cdTime = 300; // 5 seconds @ 60fps default

        if(abilityName === 'nitro') {
            player.durations[slot] = 120; // 2s active
            cdTime = 600;
        } else if(abilityName === 'phase') {
            player.isPhasing = true;
            player.durations[slot] = 300; // 5s active
            cdTime = 900; 
        } else if(abilityName === 'dash') {
            player.vx += Math.cos(player.angle) * 30;
            player.vy += Math.sin(player.angle) * 30;
            createExplosion(player.x, player.y, '#ffff00', 10);
            cdTime = 300;
        } else if(abilityName === 'jam') {
            // Find nearest target
            let target = findNearestTarget();
            if(target) {
                // If local (single player bot)
                if(target.isBot) target.confused = 180; // 3 seconds
                // If multiplayer, emit event
                else if(roomCode) socket.emit('jamPlayer', { room: roomCode, targetId: target.id });
                
                // Visual beam
                particles.push({type:'beam', x1:player.x, y1:player.y, x2:target.x, y2:target.y, life:30});
                cdTime = 900;
            } else {
                return; // Don't burn CD if no target
            }
        }

        player.cooldowns[slot] = cdTime;
    }

    function findNearestTarget() {
        let nearest = null;
        let minDist = 1000;
        // Check bots
        bots.forEach(b => {
            let d = Math.hypot(b.x - player.x, b.y - player.y);
            if(d < minDist) { minDist = d; nearest = b; }
        });
        // Check players (multiplayer)
        for(let id in opponents) {
            if(id === socket.id) continue;
            let p = opponents[id];
            let d = Math.hypot(p.x - player.x, p.y - player.y);
            if(d < minDist) { minDist = d; nearest = p; }
        }
        return nearest;
    }

    // --- GAME LOOP ---
    function gameLoop() {
        if(gameState === 'playing' || gameState === 'openworld') {
            updatePhysics();
            updateBots();
            updateParticles();
            
            // Render
            ctx.fillStyle = '#050508'; ctx.fillRect(0,0,width,height);
            
            updateCamera();
            drawWorld(ctx, true);
            
            // HUD Maps
            drawMap(mmCtx, 200, 200, 0.015, false);
            if(isBigMapOpen) drawMap(bmCtx, bmCanvas.width, bmCanvas.height, 0.05, true);

            updateHUD();
        }
        requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);

    // --- PHYSICS & UPDATES ---
    function updatePhysics() {
        if(player.dead) return;

        // Ability Tick
        ['q','r'].forEach(slot => {
            if(player.cooldowns[slot] > 0) player.cooldowns[slot]--;
            if(player.durations[slot] > 0) {
                player.durations[slot]--;
                if(player.durations[slot] <= 0) {
                    // End effects
                    if(SHIPS[player.primary]?.ability === 'phase' && slot === 'q') player.isPhasing = false;
                    if(SHIPS[player.secondary]?.ability === 'phase' && slot === 'r') player.isPhasing = false;
                }
            }
        });

        // Controls
        let turnSpeed = 0.06;
        let accel = 0.3;
        let maxSpeed = 12;

        // Vision Jam Effect
        let inputMult = player.controlsInverted ? -1 : 1;
        if(player.controlsInverted) {
            player.invertTimer--;
            if(player.invertTimer <= 0) player.controlsInverted = false;
            // Glitch effect
            if(Math.random() > 0.8) camera.x += (Math.random()-0.5)*20;
        }

        if(keys.a) player.angle -= turnSpeed * inputMult;
        if(keys.d) player.angle += turnSpeed * inputMult;
        
        // Nitro Boost Passive or Active
        let boost = 1;
        if(player.durations.q > 0 && SHIPS[player.primary].ability === 'nitro') boost = 2;
        if(player.durations.r > 0 && SHIPS[player.secondary].ability === 'nitro') boost = 2;

        if(keys.w) {
            player.vx += Math.cos(player.angle) * accel * boost;
            player.vy += Math.sin(player.angle) * accel * boost;
            if(Math.random()>0.5) particles.push({x:player.x, y:player.y, vx:0, vy:0, life:20, color: boost>1?'#00ffff':'orange'});
        }
        if(keys.s) { player.vx *= 0.9; player.vy *= 0.9; }

        // Friction
        player.vx *= 0.97; player.vy *= 0.97;

        // Velocity Cap
        let speed = Math.hypot(player.vx, player.vy);
        if(speed > maxSpeed * boost) {
            let r = (maxSpeed * boost) / speed;
            player.vx *= r; player.vy *= r;
        }

        player.x += player.vx;
        player.y += player.vy;

        // Collisions
        if(!player.isPhasing) {
            walls.forEach(w => {
                let dx = player.x - w.x; let dy = player.y - w.y;
                let lx = dx * Math.cos(-w.angle) - dy * Math.sin(-w.angle);
                let ly = dx * Math.sin(-w.angle) + dy * Math.cos(-w.angle);
                if(Math.abs(lx) < w.w/2 + 10 && Math.abs(ly) < w.h/2 + 10) {
                    player.vx *= -0.5; player.vy *= -0.5;
                    player.x -= player.vx * 4; player.y -= player.vy * 4;
                }
            });
        }

        if(roomCode) socket.emit('playerMove', { room:roomCode, x:player.x, y:player.y, angle:player.angle, dead:player.dead });
    }

    function updateBots() {
        bots.forEach(b => {
            if(b.confused > 0) {
                b.confused--;
                b.angle += (Math.random()-0.5) * 0.5; // Spin wildy
            } else {
                // Simple track follow
                let target = track[b.node || 0];
                if(target) {
                    let a = Math.atan2(target.y - b.y, target.x - b.x);
                    let diff = a - b.angle;
                    while(diff < -Math.PI) diff += Math.PI*2;
                    while(diff > Math.PI) diff -= Math.PI*2;
                    b.angle += diff * 0.05;
                    if(Math.hypot(target.x - b.x, target.y - b.y) < target.radius) b.node = (b.node+1)%track.length;
                }
            }
            b.vx += Math.cos(b.angle)*0.25; b.vy += Math.sin(b.angle)*0.25;
            b.vx *= 0.96; b.vy *= 0.96;
            b.x += b.vx; b.y += b.vy;
        });
    }

    function updateParticles() {
        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i];
            p.life--;
            if(p.type !== 'beam') { p.x += p.vx; p.y += p.vy; }
            if(p.life <= 0) particles.splice(i,1);
        }
    }

    function updateCamera() {
        // Follow player with smoothing
        let targetX = player.x - width/2;
        let targetY = player.y - height/2;
        if(player.controlsInverted && Math.random() > 0.8) {
            // Shake effect for Jam
            targetX += (Math.random()-0.5)*50;
        }
        camera.x += (targetX - camera.x) * 0.1;
        camera.y += (targetY - camera.y) * 0.1;
    }

    // --- DRAWING ---
    function drawWorld(ctx, applyCam) {
        ctx.save();
        if(applyCam) ctx.translate(-camera.x, -camera.y);

        // Grid
        ctx.strokeStyle = '#222'; ctx.lineWidth = 2;
        let gridSize = 500;
        let startX = Math.floor(camera.x/gridSize)*gridSize;
        let startY = Math.floor(camera.y/gridSize)*gridSize;
        ctx.beginPath();
        for(let x=startX; x<camera.x+width; x+=gridSize) { ctx.moveTo(x, camera.y); ctx.lineTo(x, camera.y+height); }
        ctx.stroke();

        // Walls
        walls.forEach(w => {
            ctx.save(); ctx.translate(w.x, w.y); ctx.rotate(w.angle);
            ctx.fillStyle = '#555'; ctx.fillRect(-w.w/2, -w.h/2, w.w, w.h);
            ctx.lineWidth = 3; ctx.strokeStyle = '#fff'; ctx.strokeRect(-w.w/2, -w.h/2, w.w, w.h);
            ctx.restore();
        });

        // Particles
        particles.forEach(p => {
            if(p.type === 'beam') {
                ctx.beginPath(); ctx.moveTo(p.x1, p.y1); ctx.lineTo(p.x2, p.y2);
                ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 4; ctx.stroke();
            } else {
                ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 4, 4);
            }
        });

        // Bots
        bots.forEach(b => drawShip(ctx, b.x, b.y, b.angle, '#aa00ff', false));
        
        // Opponents
        for(let id in opponents) {
            if(id !== socket.id) drawShip(ctx, opponents[id].x, opponents[id].y, opponents[id].angle, '#ff4444', false);
        }

        // Player
        if(!player.dead) {
            let opacity = player.isPhasing ? 0.4 : 1.0;
            ctx.globalAlpha = opacity;
            let c = SHIPS[player.primary] ? SHIPS[player.primary].color : '#fff';
            drawShip(ctx, player.x, player.y, player.angle, c, true);
            
            // Nav Arrow
            if(waypoint) {
                let a = Math.atan2(waypoint.y - player.y, waypoint.x - player.x);
                let dist = Math.hypot(waypoint.x - player.x, waypoint.y - player.y);
                ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(a);
                ctx.fillStyle = '#00ff00';
                ctx.beginPath(); ctx.moveTo(60,0); ctx.lineTo(50, -5); ctx.lineTo(50, 5); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.font = "12px monospace"; ctx.fillText(Math.round(dist)+"m", 70, 4);
                ctx.restore();
            }
            ctx.globalAlpha = 1.0;
        }

        ctx.restore();
    }

    function drawShip(ctx, x, y, ang, color, isSelf) {
        ctx.save(); ctx.translate(x, y); ctx.rotate(ang);
        
        // Base
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.moveTo(20,0); ctx.lineTo(-15, 15); ctx.lineTo(-5,0); ctx.lineTo(-15, -15); ctx.fill();
        
        // Cockpit
        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-2, 0, 5, 0, Math.PI*2); ctx.fill();
        
        // Status Indicators
        if(isSelf && player.isPhasing) { ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke(); }
        
        ctx.restore();
    }

    function drawMap(ctx, w, h, scale, full) {
        ctx.fillStyle = full ? 'rgba(0,0,0,0.8)' : '#001';
        ctx.fillRect(0,0,w,h);
        
        let cx = w/2, cy = h/2;
        
        walls.forEach(obj => {
            let mx = (obj.x - player.x)*scale + cx;
            let my = (obj.y - player.y)*scale + cy;
            if(mx>0 && mx<w && my>0 && my<h) { ctx.fillStyle='#555'; ctx.fillRect(mx-2, my-2, 4, 4); }
        });

        // Player
        ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();
        
        // Waypoint
        if(waypoint) {
             let wx = (waypoint.x - player.x)*scale + cx;
             let wy = (waypoint.y - player.y)*scale + cy;
             ctx.strokeStyle = '#00ff00'; ctx.beginPath(); ctx.arc(wx, wy, 5, 0, Math.PI*2); ctx.stroke();
        }
    }

    // --- HANGAR & ECONOMY UI ---
    
    // Timer Logic
    setInterval(() => {
        let now = Date.now();
        let diff = 3600000 - (now - userState.lastFreeBox);
        if(diff <= 0) {
            document.getElementById('freeBoxBtn').disabled = false;
            document.getElementById('freeBoxBtn').innerText = "CLAIM FREE BOX";
            document.getElementById('timerDisplay').innerText = "READY";
        } else {
            let mins = Math.floor(diff / 60000);
            document.getElementById('freeBoxBtn').disabled = true;
            document.getElementById('freeBoxBtn').innerText = "Wait " + mins + "m";
            document.getElementById('timerDisplay').innerText = mins + "m";
        }
        
        // Update Cooldown UI
        updateCooldownUI('q');
        updateCooldownUI('r');

    }, 1000);

    function updateCooldownUI(slot) {
        let cd = player.cooldowns[slot];
        let el = document.getElementById(slot+'AbilityUI');
        let ship = slot === 'q' ? SHIPS[player.primary] : SHIPS[player.secondary];
        
        if(!ship) {
            el.innerHTML = `[${slot.toUpperCase()}] -- : <span style="color:#555">EMPTY</span>`;
            return;
        }

        if(cd > 0) {
            let sec = Math.ceil(cd/60);
            el.innerHTML = `[${slot.toUpperCase()}] ${ship.name.toUpperCase()}: <span style="color:orange">${sec}s</span>`;
        } else {
            el.innerHTML = `[${slot.toUpperCase()}] ${ship.name.toUpperCase()}: <span class="ability-ready">READY</span>`;
        }
    }

    function openHangar() {
        showMenu('hangarMenu');
        updateHangarUI();
    }

    let selectedShipForMerge = null;

    function updateHangarUI() {
        document.getElementById('hangarPoints').innerText = userState.points;
        const container = document.getElementById('cardContainer');
        container.innerHTML = '';

        for(let key in SHIPS) {
            let ship = SHIPS[key];
            let count = userState.cards[key];
            let unlocked = count >= 10;
            
            let div = document.createElement('div');
            div.className = `ship-card ${unlocked ? 'unlocked' : ''}`;
            if(selectedShipForMerge === key) div.classList.add('selected');
            
            div.onclick = () => selectShipCard(key, unlocked);
            
            let html = `
                <div class="card-title">${ship.name}</div>
                <div style="font-size:10px; color:${ship.color}; margin-top:5px;">${ship.desc}</div>
                <div class="card-count">${count}/10</div>
                <div class="progress-bar"><div class="progress-fill" style="width:${Math.min(100, (count/10)*100)}%"></div></div>
            `;
            if(unlocked) html += `<div style="text-align:center; color:#00ff00; font-size:10px;">UNLOCKED</div>`;
            div.innerHTML = html;
            container.appendChild(div);
        }
    }

    let mergeSlot1 = userState.equipped.primary;
    let mergeSlot2 = userState.equipped.secondary;

    function selectShipCard(key, unlocked) {
        if(!unlocked) return;
        selectedShipForMerge = key;
        updateHangarUI(); // to show selection border
        
        // Logic: Fill slot 1 first, if full fill slot 2
        // Actually, let's make it smarter.
        if(mergeSlot1 === key) {
            // Deselect logic if needed, or do nothing
        } else if (mergeSlot2 === key) {
            // Already in slot 2
        } else {
            // Shift: Slot 1 becomes old selection, Slot 2 becomes new selection?
            // Simple approach: Click sets slot 2 if slot 1 is set, unless clicked again.
            // Let's just cycle.
            if(!mergeSlot1) mergeSlot1 = key;
            else if(!mergeSlot2) mergeSlot2 = key;
            else { mergeSlot1 = mergeSlot2; mergeSlot2 = key; }
        }
        
        renderSlots();
    }

    function renderSlots() {
        const s1 = document.getElementById('slot1');
        const s2 = document.getElementById('slot2');
        
        if(mergeSlot1) {
            let s = SHIPS[mergeSlot1];
            s1.innerHTML = `<span style="color:${s.color}">${s.name}</span>`;
            s1.style.borderColor = s.color;
        } else { s1.innerHTML = "[Q] Empty"; s1.style.borderColor = "#555"; }

        if(mergeSlot2) {
            let s = SHIPS[mergeSlot2];
            s2.innerHTML = `<span style="color:${s.color}">${s.name}</span>`;
            s2.style.borderColor = s.color;
        } else { s2.innerHTML = "[R] Empty"; s2.style.borderColor = "#555"; }
    }

    function equipCurrentSelection() {
        userState.equipped.primary = mergeSlot1;
        userState.equipped.secondary = mergeSlot2;
        player.primary = mergeSlot1;
        player.secondary = mergeSlot2;
        saveState();
        alert("Configuration Equipped!");
    }

    function claimFreeBox() {
        let now = Date.now();
        if(now - userState.lastFreeBox >= 3600000) {
            userState.lastFreeBox = now;
            saveState();
            openLootBox();
        }
    }

    function buyLootBox() {
        if(userState.points >= 1000) {
            userState.points -= 1000;
            saveState();
            openLootBox();
        } else {
            alert("Not enough points!");
        }
    }

    function openLootBox() {
        document.getElementById('lootOverlay').style.display = 'flex';
        document.getElementById('lootResults').innerHTML = '';
        document.getElementById('lootCloseBtn').style.display = 'none';
        
        // Random drops
        let drops = [];
        let numCards = 3 + Math.floor(Math.random()*3); // 3 to 5 cards
        let keys = Object.keys(SHIPS);
        
        for(let i=0; i<numCards; i++) {
            let k = keys[Math.floor(Math.random()*keys.length)];
            drops.push(k);
            userState.cards[k]++;
        }
        saveState();

        // Animation sequence
        setTimeout(() => {
            document.getElementById('lootTitle').innerText = "BOX OPENED!";
            drops.forEach((d, i) => {
                setTimeout(() => {
                    let div = document.createElement('div');
                    div.className = 'card-reveal show';
                    div.innerHTML = `+1 ${SHIPS[d].name} Card`;
                    div.style.color = SHIPS[d].color;
                    document.getElementById('lootResults').appendChild(div);
                }, i * 500);
            });
            setTimeout(() => {
                document.getElementById('lootCloseBtn').style.display = 'block';
            }, drops.length * 500 + 500);
        }, 1500);
    }

    function closeLoot() {
        document.getElementById('lootOverlay').style.display = 'none';
        document.getElementById('lootTitle').innerText = "OPENING...";
        updateHangarUI();
    }

    function updateHUD() {
        document.getElementById('scoreDisplay').innerText = userState.points;
        let pName = SHIPS[player.primary] ? SHIPS[player.primary].name : "None";
        let sName = SHIPS[player.secondary] ? "+" + SHIPS[player.secondary].name : "";
        document.getElementById('currentShipName').innerText = pName + sName;
        document.getElementById('coordDisplay').innerText = Math.round(player.x)+","+Math.round(player.y);
        document.getElementById('speedDisplay').innerText = Math.round(Math.hypot(player.vx, player.vy)*10);
    }

    // --- SETUP GAMES ---
    function setupSinglePlayer() {
        userState.points += 100; // Gift points for playing
        saveState();
        
        player.primary = userState.equipped.primary;
        player.secondary = userState.equipped.secondary;
        player.dead = false; player.x=0; player.y=0;
        
        roomCode = null;
        gameState = 'playing';
        showMenu(null);
        document.getElementById('chatContainer').style.display = 'block';

        // Gen Walls
        walls = [];
        for(let i=0; i<20; i++) {
            walls.push({
                x: (Math.random()-0.5)*3000,
                y: (Math.random()-0.5)*3000,
                w: 200 + Math.random()*400,
                h: 50,
                angle: Math.random()*Math.PI
            });
        }
        
        // Gen Bots
        bots = [];
        for(let i=0; i<3; i++) {
            bots.push({
                id: 'bot'+i, isBot:true,
                x: (Math.random()-0.5)*500, y: (Math.random()-0.5)*500,
                vx:0, vy:0, angle:0,
                node: 0, confused: 0
            });
        }
        track = [{x:0,y:0,radius:100}, {x:1000,y:-1000,radius:100}, {x:2000,y:0,radius:100}];
    }

    function findOpenWorldGame() {
        socket.emit('findOpenWorld');
    }
    
    function showMenu(id) {
        document.querySelectorAll('.menu-box').forEach(el => el.classList.remove('visible'));
        if(id) document.getElementById(id).classList.add('visible');
    }
    function respawnPlayer() { player.dead=false; player.x=0; player.y=0; player.vx=0; player.vy=0; showMenu(null); }

    function createExplosion(x,y,col,count) {
        for(let i=0; i<count; i++) particles.push({x:x,y:y,vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, life:30, color:col});
    }

    // --- SOCKET HANDLERS (Minimal) ---
    socket.on('roomCreated', d => { roomCode=d.code; isHost=true; setupSinglePlayer(); }); // Reuse SP logic for physics
    socket.on('roomJoined', d => { roomCode=d.code; isHost=false; setupSinglePlayer(); });
    socket.on('playerMoved', d => { opponents[d.id] = d; });
    socket.on('jamPlayer', d => {
        // If server says I am jammed
        if(d.targetId === socket.id) {
            player.controlsInverted = true;
            player.invertTimer = 180; // 3s
            alert("SYSTEM JAMMED BY ENEMY!"); // Optional visual
        }
    });

</script>
</body>
</html>
