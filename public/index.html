<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Stellar Drift: INFINITE VELOCITY</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050508; color: white; font-family: 'Segoe UI', monospace; user-select: none; }
        canvas { display: block; }

        /* UI LAYERS */
        #ui, #hud-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .menu-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; pointer-events: none; z-index: 20; }
        
        /* BIG MAP */
        #bigMapOverlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(5, 10, 20, 0.95); z-index: 150; display: none; 
            pointer-events: auto; backdrop-filter: blur(5px);
        }
        #bigMapContainer { position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; }

        /* MENUS */
        .menu-box { pointer-events: auto; background: rgba(16, 20, 35, 0.98); padding: 30px; border: 2px solid #00d2ff; text-align: center; border-radius: 12px; display: none; box-shadow: 0 0 30px rgba(0, 210, 255, 0.2); min-width: 350px; max-height: 80vh; overflow-y: auto; }
        .visible { display: block; }

        h1 { color: #00d2ff; text-transform: uppercase; margin-top: 0; font-style: italic; letter-spacing: 2px; }
        h2 { border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 20px; }
        
        button { background: linear-gradient(45deg, #00d2ff, #0078ff); border: none; padding: 12px 24px; color: #fff; font-weight: bold; cursor: pointer; margin: 8px; border-radius: 4px; text-transform: uppercase; transition: 0.2s; }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0, 210, 255, 0.4); }
        button.secondary { background: #333; color: #aaa; }
        button.gold { background: linear-gradient(45deg, #ffd700, #ffaa00); color: black; }
        button.purple { background: linear-gradient(45deg, #aa00ff, #5500ff); color: white; }
        button.red { background: linear-gradient(45deg, #ff4444, #990000); color: white; font-size: 10px; padding: 5px 10px; margin-top: 5px; }

        input { padding: 10px; background: #111; border: 1px solid #444; color: white; text-align: center; }

        /* HUD */
        .hud-stats { position: absolute; top: 20px; left: 20px; font-weight: bold; text-shadow: 0 2px 4px black; pointer-events: none; }
        .fps-counter { position: absolute; top: 10px; right: 10px; font-weight: bold; color: #00ff00; font-family: monospace; font-size: 12px; z-index: 100; pointer-events:none; }
        
        /* ALERT OVERLAYS */
        #slingshotAlert {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; display: none;
        }
        .sling-text { font-size: 30px; font-weight: 900; color: #fff; text-shadow: 0 0 20px #bf00ff; letter-spacing: 5px; font-style: italic; animation: pulse 0.1s infinite; }
        .sling-sub { font-size: 16px; color: #ddd; margin-top: 10px; text-shadow: 0 2px 5px black; }
        
        #hyperspeedAlert {
            position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%);
            font-size: 40px; color: #00ffff; font-weight: 900; font-style: italic;
            text-shadow: 0 0 20px cyan; display: none; letter-spacing: 10px;
            white-space: nowrap;
        }

        #speedWarning {
            position: absolute; top: 10%; left: 50%; transform: translateX(-50%);
            color: red; font-size: 12px; display: none; text-shadow: 0 0 5px red;
            background: rgba(0,0,0,0.8); padding: 5px; border: 1px solid red;
        }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        /* SHIP SWITCHER */
        #shipSwitcher {
            position: absolute; top: 50%; right: 20px; transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 10px; pointer-events: auto; display: none;
        }
        .switch-btn {
            width: 50px; height: 50px; background: rgba(0,0,0,0.8); border: 1px solid #444;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; color: #555; cursor: pointer; border-radius: 8px;
            transition: 0.2s; position: relative;
        }
        .switch-btn.active { border-color: #00d2ff; background: rgba(0, 210, 255, 0.1); color: white; box-shadow: 0 0 10px rgba(0,210,255,0.5); transform: scale(1.1); }
        .switch-btn .key-hint { position: absolute; top: 2px; left: 4px; font-size: 8px; color: #aaa; }
        
        .ability-row { margin-top: 5px; font-size: 14px; color: #aaa; }
        .ready { color: #00ff00; text-shadow: 0 0 5px #00ff00; }
        .cooldown { color: orange; }
        .locked-slot { color: #555; font-style: italic; }
        .mastered-hud { color: #ffd700; text-shadow: 0 0 5px gold; }
        
        /* CHAT */
        #chatContainer { position: absolute; bottom: 80px; left: 20px; width: 300px; pointer-events: auto; z-index: 100; display: none; }
        #chatMessages { height: 150px; overflow-y: auto; background: rgba(0,0,0,0.6); border: 1px solid #444; padding: 10px; list-style: none; margin: 0; color: #ddd; font-size: 13px; }
        #chatInput { width: 100%; box-sizing: border-box; margin-top: 5px; text-align: left; background: rgba(0,0,0,0.8); }

        /* BUILD TOOLBAR */
        #buildToolbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px; border: 1px solid #444;
            display: none; pointer-events: auto;
        }
        .tool-btn { background: #222; border: 1px solid #555; color: #ddd; margin: 0 5px; padding: 5px 10px; cursor: pointer; }
        .tool-btn.active { background: #00d2ff; color: #000; border-color: #fff; }

        /* HANGAR CARDS */
        .ship-card { display: inline-block; width: 120px; height: 180px; background: #111; border: 1px solid #444; margin: 5px; border-radius: 6px; position: relative; cursor: pointer; vertical-align: top; transition: 0.1s; }
        .ship-card:hover { background: #1a1a1a; }
        .ship-card.unlocked { border-color: #00d2ff; background: #081018; }
        .ship-card.mastered { border-color: #ffd700; background: #1a1500; box-shadow: 0 0 15px rgba(255, 215, 0, 0.1); }
        .ship-card.selected { border-color: #fff; box-shadow: 0 0 10px #fff; transform: scale(1.05); }
        .card-name { font-size: 12px; font-weight: bold; margin-top: 8px; }
        .card-bar-bg { width: 80%; height: 6px; background: #222; margin: 5px auto; border-radius:3px; overflow:hidden; }
        .card-fill { height: 100%; transition: width 0.3s; }

        /* LOOT ANIMATION */
        #lootOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 200; display: none; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        .loot-box { width: 100px; height: 100px; background: gold; margin-bottom: 20px; box-shadow: 0 0 50px gold; animation: shake 0.5s infinite; }
        @keyframes shake { 0% { transform: rotate(0deg); } 25% { transform: rotate(5deg); } 75% { transform: rotate(-5deg); } 100% { transform: rotate(0deg); } }
        .loot-msg { font-size: 24px; color: #ffd700; margin-bottom: 20px; font-weight: bold; }

        /* DEV NOTIFICATION */
        #devNotif {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9); border: 2px solid #00ff00; color: #00ff00;
            padding: 30px; font-size: 24px; font-weight: bold; z-index: 300;
            box-shadow: 0 0 50px #00ff00; display: none; text-align: center;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<div id="fpsDisplay" class="fps-counter">FPS: 60</div>
<div id="devNotif">DEV MODE ACTIVATED<br><span style="font-size:14px; color:white;">Unlimited Power Granted</span></div>

<div id="shipSwitcher">
    <div class="switch-btn" id="switch-nitro" onclick="switchShipInGame('nitro')"><span class="key-hint">1</span>N</div>
    <div class="switch-btn" id="switch-shadow" onclick="switchShipInGame('shadow')"><span class="key-hint">2</span>S</div>
    <div class="switch-btn" id="switch-vision" onclick="switchShipInGame('vision')"><span class="key-hint">3</span>V</div>
    <div class="switch-btn" id="switch-dasher" onclick="switchShipInGame('dasher')"><span class="key-hint">4</span>D</div>
</div>

<div id="bigMapOverlay">
    <div id="bigMapContainer">
        <div style="color:#00d2ff; font-size:24px; font-weight:bold; margin-bottom:10px;">TACTICAL MAP</div>
        <canvas id="bigMapCanvas"></canvas>
        <div style="color:#aaa; font-size:14px; margin-top:10px;">CLICK to Set Waypoint | Press [M] to Close</div>
    </div>
</div>

<div id="lootOverlay">
    <div id="lootBoxVisual" class="loot-box"></div>
    <h1 id="lootText" style="color:white;">OPENING...</h1>
    <div id="lootMsg" class="loot-msg"></div>
    <div id="lootResults" style="display:flex; gap:10px; margin-top:20px;"></div>
    <button id="lootClose" style="display:none; margin-top:30px;" onclick="closeLoot()">Collect</button>
</div>

<div id="hud-layer" style="display:none;">
    <div class="hud-stats">
        <div id="raceInfo" style="display:none;">
            <div style="font-size:30px; color:#ffd700; font-style:italic;">LAP <span id="lapDisplay">1/3</span></div>
            <div>POS: <span id="posDisplay">1/4</span></div>
        </div>
        <div style="margin-top:10px;">SPEED: <span id="speedDisplay" style="color:#00d2ff; font-size:24px;">0</span></div>
        <div class="ability-row" id="ui-q">[Q] <span id="name-q">NITRO</span>: <span id="status-q" class="ready">READY</span></div>
        <div class="ability-row" id="ui-r">[R] <span id="name-r">--</span>: <span id="status-r" class="ready">EMPTY</span></div>
        <div style="margin-top:10px; font-size:12px; color:#aaa;">POINTS: <span id="hudPoints">0</span></div>
    </div>

    <div id="slingshotAlert">
        <div class="sling-text">GRAVITY LOCKED</div>
        <div class="sling-sub">VELOCITY INCREASING INFINITELY...<br>PRESS [SPACE] TO LAUNCH</div>
    </div>
    
    <div id="hyperspeedAlert">HYPERSPEED</div>
    <div id="speedWarning">WARNING: PHYSICS BREAKDOWN IMMINENT</div>

    <div id="chatContainer">
        <ul id="chatMessages"><li style="color:yellow">System: Online...</li></ul>
        <input id="chatInput" type="text" placeholder="Press Enter to Chat...">
    </div>

    <div style="position:absolute; bottom:20px; right:20px; width:180px; height:180px; border-radius:50%; overflow:hidden; border:2px solid #00d2ff; background:#001;">
        <canvas id="minimapCanvas" width="180" height="180"></canvas>
    </div>

    <div id="buildToolbar">
        <button class="tool-btn active" onclick="setBuildTool(0)">FLY</button>
        <button class="tool-btn" onclick="setBuildTool(1)">WALL</button>
        <button class="tool-btn" onclick="setBuildTool(2)">BARRIER</button>
        <button class="tool-btn" onclick="setBuildTool(3)">CRATE</button>
    </div>
</div>

<div class="menu-layer">
    <div id="mainMenu" class="menu-box visible">
        <h1>Stellar Drift</h1>
        <p>Limitless Hyperspeed Update</p>
        <button onclick="setupRace()">Single Player Race</button>
        <button class="gold" onclick="setupOpenWorld()">Open World Online</button>
        <button onclick="showMenu('multiplayerMenu')">Multiplayer Race</button><br>
        <button class="purple" onclick="openHangar()">HANGAR & LOOT</button>
    </div>

    <div id="hangarMenu" class="menu-box" style="width:700px;">
        <h2>SHIP HANGAR</h2>
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; background:#111; padding:10px; border-radius:8px;">
            <div>Points: <span id="hangarPoints" style="color:#00d2ff; font-weight:bold;">0</span></div>
            <div>Merge Tokens: <span id="hangarTokens" style="color:#ff00ff; font-weight:bold;">0</span></div>
            <button class="gold" onclick="buyBox()">Buy Box (1000pts)</button>
        </div>
        <div id="cardContainer" style="text-align:left; margin-bottom:20px; padding-bottom:10px; border-bottom:1px solid #333; overflow-x:auto; white-space:nowrap;"></div>
        <h3>MERGE STATION</h3>
        <p style="font-size:12px; color:#aaa;">Requirement: 100 Cards to Unlock. 450 Cards for Mastery (20% CDR).</p>
        <div style="display:flex; justify-content:center; gap:20px; align-items:center; margin-bottom:20px;">
            <div id="slotQ" onclick="equipTo('q')" style="border:1px dashed #555; width:120px; height:80px; display:flex; align-items:center; justify-content:center; cursor:pointer;">[Q] Primary</div>
            <div style="font-size:24px;">+</div>
            <div id="slotR_Container"><div id="slotR" onclick="equipTo('r')" style="border:1px dashed #555; width:120px; height:80px; display:flex; align-items:center; justify-content:center; cursor:pointer;">[R] Secondary</div></div>
        </div>
        <button class="secondary" onclick="saveAndExitHangar()">Save & Back</button>
    </div>

    <div id="multiplayerMenu" class="menu-box">
        <h2>Multiplayer Lobby</h2>
        <button onclick="createRoom()">Create Room</button><br>
        <input id="roomInput" placeholder="Room Code">
        <button onclick="joinRoom()">Join</button><br>
        <button class="secondary" onclick="showMenu('mainMenu')">Back</button>
    </div>
    
    <div id="finishMenu" class="menu-box">
        <h1 style="color:#ffd700">FINISHED!</h1>
        <h2 id="finishRank">1st Place</h2>
        <p style="color:#00ff00; font-size:20px;">+<span id="finishPoints">0</span> Points</p>
        <div id="tokenReward" style="color:#ff00ff; font-weight:bold; margin-bottom:10px; display:none;">+1 MERGE TOKEN!</div>
        <button onclick="setupRace()">Race Again</button>
        <button class="secondary" onclick="showMenu('mainMenu')">Main Menu</button>
    </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const mmCanvas = document.getElementById('minimapCanvas');
    const mmCtx = mmCanvas.getContext('2d');
    const bmCanvas = document.getElementById('bigMapCanvas');
    const bmCtx = bmCanvas.getContext('2d');
    const fpsEl = document.getElementById('fpsDisplay');
    const shipSwitcherEl = document.getElementById('shipSwitcher');
    
    let socket;
    try { socket = io(); } catch(e) { console.log("Offline Mode"); }

    let width, height;
    function resize() { 
        width=canvas.width=window.innerWidth; height=canvas.height=window.innerHeight; 
        bmCanvas.width = window.innerWidth * 0.9; bmCanvas.height = window.innerHeight * 0.8;
    }
    window.addEventListener('resize', resize);
    resize();

    const SHIPS = {
        nitro: { name: "Nitro", color: "#00d2ff", desc: "Speed Boost", cd: 600, dur: 120 },
        shadow: { name: "Shadow", color: "#444444", desc: "Phase Walls", cd: 900, dur: 300 },
        vision: { name: "Vision", color: "#ff00ff", desc: "Jam Enemies", cd: 900, dur: 0 },
        dasher: { name: "Dasher", color: "#ffff00", desc: "Teleport", cd: 300, dur: 0 }
    };

    const REQ_UNLOCK = 100, REQ_MAX = 450;
    let user = JSON.parse(localStorage.getItem('drift_user_v5')) || { points: 5000, mergeTokens: 0, slotRUnlocked: false, cards: { nitro: 100, shadow: 0, vision: 0, dasher: 0 }, slots: { q: 'nitro', r: null } };
    function saveUser() { localStorage.setItem('drift_user_v5', JSON.stringify(user)); }

    const KONAMI = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a', 'Enter'];
    let konamiIndex = 0;

    let gameState = 'menu';
    // New flag: isHyperspeed
    let player = { x:0, y:0, vx:0, vy:0, angle:0, cooldowns:{q:0, r:0}, active:{q:0, r:0}, lap:1, nextCheck:0, finished:false, wormholeDelay:0, friction:0.96, isSlingshot:false, isHyperspeed:false, slingCooldown:0 };
    let camera = { x:0, y:0 };
    let bots = [], walls = [], particles = [], planets = [], meteors = [], wormholes = [];
    let waypoint = null, track = [];
    let keys = { w:false, a:false, s:false, d:false, space:false };
    let buildTool = 0, mouse = { x:0, y:0 }, lastTime = 0;
    
    const MAP_SIZE = 5000;
    const NUM_PLANETS = 15;
    const NUM_METEORS = 50;
    const NUM_WORMHOLES = 8;

    window.addEventListener('keydown', e => {
        if(KONAMI[konamiIndex] === e.key) { konamiIndex++; if(konamiIndex === KONAMI.length) { activateDevMode(); konamiIndex = 0; } } else { konamiIndex = 0; }
        if(document.activeElement.tagName === 'INPUT') return;
        if(gameState === 'openworld') {
            if(e.key === '1') switchShipInGame('nitro');
            if(e.key === '2') switchShipInGame('shadow');
            if(e.key === '3') switchShipInGame('vision');
            if(e.key === '4') switchShipInGame('dasher');
        }
        if(e.key==='w'||e.key==='ArrowUp') keys.w=true;
        if(e.key==='s'||e.key==='ArrowDown') keys.s=true;
        if(e.key==='a'||e.key==='ArrowLeft') keys.a=true;
        if(e.key==='d'||e.key==='ArrowRight') keys.d=true;
        if(e.key===' '||e.key==='Space') keys.space=true;
        if(e.key==='q') useAbility('q');
        if(e.key==='r') useAbility('r');
        if(e.key==='m') toggleBigMap();
    });
    window.addEventListener('keyup', e => {
        if(e.key==='w'||e.key==='ArrowUp') keys.w=false;
        if(e.key==='s'||e.key==='ArrowDown') keys.s=false;
        if(e.key==='a'||e.key==='ArrowLeft') keys.a=false;
        if(e.key==='d'||e.key==='ArrowRight') keys.d=false;
        if(e.key===' '||e.key==='Space') keys.space=false;
    });
    window.addEventListener('mousemove', e => { mouse.x=e.clientX; mouse.y=e.clientY; });
    window.addEventListener('mousedown', (e) => {
        if(gameState === 'openworld' && buildTool > 0 && document.getElementById('bigMapOverlay').style.display !== 'block') {
            let wx = camera.x + mouse.x, wy = camera.y + mouse.y;
            let w=100, h=20; if(buildTool===2) { w=400; h=40; } if(buildTool===3) { w=60; h=60; }
            let obj = { x:wx, y:wy, w:w, h:h, angle:player.angle };
            walls.push(obj);
            if(socket) socket.emit('buildObject', obj);
        }
    });

    document.getElementById('chatInput').addEventListener('keydown', e => {
        if(e.key === 'Enter') { addChat("You", e.target.value, true); if(socket) socket.emit('chatMsg', e.target.value); e.target.value = ""; }
    });

    function addChat(user, msg, self) {
        let ul = document.getElementById('chatMessages');
        let li = document.createElement('li'); li.innerText = `[${user}]: ${msg}`; li.style.color = self ? '#00ffff' : '#ffaaaa';
        ul.appendChild(li); ul.scrollTop = ul.scrollHeight;
    }

    function activateDevMode() {
        user.points = 9999999; user.mergeTokens = 9999; user.slotRUnlocked = true;
        for(let k in user.cards) user.cards[k] = 450;
        saveUser();
        let notif = document.getElementById('devNotif'); notif.style.display = 'block'; setTimeout(() => { notif.style.display = 'none'; }, 3000);
        if(document.getElementById('hangarMenu').classList.contains('visible')) renderHangar();
        updateShipSwitcherUI();
    }

    function loop(timestamp) {
        if(!lastTime) lastTime = timestamp;
        let delta = timestamp - lastTime; lastTime = timestamp;
        if(delta > 0) { let fps = Math.round(1000/delta); fpsEl.innerText = "FPS: " + fps; fpsEl.style.color = fps < 30 ? 'red' : '#00ff00'; }

        if(gameState !== 'menu') {
            if(gameState === 'openworld') updateSlingshot();
            updatePhysics();
            if(gameState === 'race') updateRaceLogic();
            updateHazards();
            updateParticles();
            
            // Screen Shake & Distortion based on speed
            let speed = Math.hypot(player.vx, player.vy);
            let shake = speed > 20 ? (speed-20)*0.5 : 0;
            // Cap visual shake slightly so you can see, but keep distortion high
            let viewShake = Math.min(shake, 15); 
            
            let sx = (Math.random()-0.5)*viewShake; let sy = (Math.random()-0.5)*viewShake;

            camera.x += ((player.x - width/2) - camera.x) * 0.1; 
            camera.y += ((player.y - height/2) - camera.y) * 0.1;
            
            ctx.save();
            ctx.translate(sx, sy); // Apply shake

            // HYPERSPEED STRETCH (Visual Distortion)
            if(speed > 100) {
                let stretch = Math.min(speed / 100, 2.0); // Limit stretch slightly to prevent total nausea
                let angle = Math.atan2(player.vy, player.vx);
                ctx.translate(width/2, height/2);
                ctx.rotate(angle);
                ctx.scale(stretch, 1/stretch); // Stretch forward, squish sideways
                ctx.rotate(-angle);
                ctx.translate(-width/2, -height/2);
            }

            drawWorld(); 
            ctx.restore();
            
            drawHUD();
        }
        requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // --- SLINGSHOT & HYPERSPEED MECHANIC ---
    function updateSlingshot() {
        if(player.slingCooldown > 0) player.slingCooldown--;

        // Only look for planets if we aren't already in hyperspeed or slinging
        if(player.isHyperspeed) {
            document.getElementById('hyperspeedAlert').style.display = 'block';
            return; 
        } else {
            document.getElementById('hyperspeedAlert').style.display = 'none';
        }

        let caught = false;
        if(player.slingCooldown <= 0) {
            planets.forEach(p => {
                let dist = Math.hypot(p.x - player.x, p.y - player.y);
                // Detection Radius
                if(dist < p.r + 250) {
                    if(!player.isSlingshot) {
                        player.isSlingshot = true; // LOCK ON
                        addChat("System", "GRAVITY LOCK ESTABLISHED", true);
                    }
                    caught = true;
                    
                    // SLINGSHOT PHYSICS: INFINITE SPEED
                    let dx = player.x - p.x;
                    let dy = player.y - p.y;
                    let angle = Math.atan2(dy, dx);
                    let currentSpeed = Math.hypot(player.vx, player.vy);
                    
                    if(currentSpeed < 10) currentSpeed = 10;
                    
                    // --- THE INFINITE MULTIPLIER ---
                    // 2% growth per frame. Doubles every ~35 frames.
                    currentSpeed *= 1.02; 
                    // NO CAP REMOVED HERE. 

                    // Force Circular Orbit Velocity (Clockwise)
                    let orbitAngle = angle + Math.PI/2;
                    player.vx = Math.cos(orbitAngle) * currentSpeed;
                    player.vy = Math.sin(orbitAngle) * currentSpeed;

                    // Pull in
                    let targetR = p.r + 100;
                    let rDiff = dist - targetR;
                    player.x -= Math.cos(angle) * (rDiff * 0.1);
                    player.y -= Math.sin(angle) * (rDiff * 0.1);

                    player.angle = orbitAngle;
                    spawnParticle(player.x, player.y, 'magenta', 2);
                }
            });
        }

        if(caught) {
            document.getElementById('slingshotAlert').style.display = 'block';
            let speed = Math.hypot(player.vx, player.vy);
            
            // Visual Warning for High Speed
            if(speed > 500) {
                document.getElementById('speedWarning').style.display = 'block';
            }

            // BREAK ORBIT = ENTER HYPERSPEED
            if(keys.space) {
                player.isSlingshot = false;
                player.isHyperspeed = true; // TRIGGER NO-CONTROL MODE
                player.slingCooldown = 120; // 2 seconds before you can grab another planet
                
                spawnParticle(player.x, player.y, 'white', 100);
                addChat("System", "HYPERSPEED ENGAGED: MACH " + Math.floor(speed/10), true);
            }
        } else {
            player.isSlingshot = false;
            document.getElementById('slingshotAlert').style.display = 'none';
            document.getElementById('speedWarning').style.display = 'none';
        }
    }

    function updatePhysics() {
        if(player.finished) return;
        
        let ents = [player, ...bots];
        ents.forEach(ent => {
            if(ent === player && player.isSlingshot) {
                ent.x += ent.vx; ent.y += ent.vy;
                return;
            }

            // FRICTION LOGIC
            let fric = ent === player ? player.friction : 0.96;
            
            // If in hyperspeed, reduce friction so they glide longer
            if(ent === player && player.isHyperspeed) {
                fric = 0.995; // Extremely slippery. Takes a long time to stop.
                let spd = Math.hypot(ent.vx, ent.vy);
                // Create "Warp Lines"
                if(spd > 50) {
                    let angle = Math.atan2(ent.vy, ent.vx);
                    for(let i=0; i<3; i++) {
                        particles.push({
                            x: ent.x + (Math.random()-0.5)*50,
                            y: ent.y + (Math.random()-0.5)*50,
                            vx: -Math.cos(angle) * (spd*0.5), // Particles shoot backwards
                            vy: -Math.sin(angle) * (spd*0.5),
                            s: 2, c: 'rgba(100,255,255,0.5)', life: 20
                        });
                    }
                }
            } else {
                ent.friction = 0.96; // Normal friction restoration
            }

            ent.vx *= fric; ent.vy *= fric;
            ent.x += ent.vx; ent.y += ent.vy;
            if(ent.wormholeDelay > 0) ent.wormholeDelay--;
            
            // Check Hyperspeed End
            if(ent === player && player.isHyperspeed) {
                let s = Math.hypot(ent.vx, ent.vy);
                if(s < 15) { // Threshold to regain control
                    player.isHyperspeed = false;
                    addChat("System", "Sub-Light Engines Engaged.", false);
                }
            }

            // COLLISION - Note: At high speeds (>20), this will tunnel through thin walls.
            // This is "intended" behavior for infinite speed mode.
            let isPhasing = ent === player && (player.active.q > 0 && SHIPS[user.slots.q]?.name === 'Shadow' || player.active.r > 0 && SHIPS[user.slots.r]?.name === 'Shadow');
            if(!isPhasing) {
                walls.forEach(w => {
                    let dx = ent.x - w.x, dy = ent.y - w.y;
                    let lx = dx * Math.cos(-w.angle) - dy * Math.sin(-w.angle);
                    let ly = dx * Math.sin(-w.angle) + dy * Math.cos(-w.angle);
                    if(Math.abs(lx) < w.w/2 + 15 && Math.abs(ly) < w.h/2 + 15) { ent.x -= ent.vx; ent.y -= ent.vy; ent.vx *= -0.5; ent.vy *= -0.5; }
                });
            }
        });

        // CONTROL LOCK CHECK
        if(player.isSlingshot || player.isHyperspeed) return; 

        if(keys.a) player.angle -= 0.07;
        if(keys.d) player.angle += 0.07;
        
        let speed = 0.5;
        if((player.active.q>0 && SHIPS[user.slots.q]?.name==='Nitro') || (player.active.r>0 && SHIPS[user.slots.r]?.name==='Nitro')) {
            speed = 1.0; spawnParticle(player.x, player.y, 'cyan', 5);
        }

        if(keys.w) { player.vx += Math.cos(player.angle) * speed; player.vy += Math.sin(player.angle) * speed; if(Math.random()>0.5) spawnParticle(player.x, player.y, 'orange', 1); }
        if(keys.s) { player.vx *= 0.9; player.vy *= 0.9; }

        ['q','r'].forEach(slot => { if(player.cooldowns[slot] > 0) player.cooldowns[slot]--; if(player.active[slot] > 0) player.active[slot]--; });
        if(socket && gameState === 'openworld') socket.emit('playerUpdate', { x:player.x, y:player.y, angle:player.angle });
    }

    function updateHazards() {
        if(gameState !== 'openworld') return;
        meteors.forEach(m => {
            m.x += m.vx; m.y += m.vy; m.angle += m.spin;
            if(m.x > MAP_SIZE) m.x = -MAP_SIZE; if(m.x < -MAP_SIZE) m.x = MAP_SIZE;
            if(m.y > MAP_SIZE) m.y = -MAP_SIZE; if(m.y < -MAP_SIZE) m.y = MAP_SIZE;
            if(Math.hypot(m.x - player.x, m.y - player.y) < m.s + 15) {
                player.vx = (player.x - m.x) * 0.1; player.vy = (player.y - m.y) * 0.1;
                spawnParticle(player.x, player.y, 'brown', 10);
            }
        });
        wormholes.forEach(w => {
            if(Math.hypot(w.x - player.x, w.y - player.y) < 40 && player.wormholeDelay <= 0) {
                player.x = w.tx; player.y = w.ty; player.wormholeDelay = 120;
                spawnParticle(player.x, player.y, 'cyan', 50); addChat("System", "Warp successful.", true);
            }
        });
    }

    function useAbility(slot) {
        if(gameState === 'menu' || player.finished || player.isSlingshot || player.isHyperspeed) return;
        let shipKey = user.slots[slot];
        if(!shipKey || player.cooldowns[slot] > 0) return;
        let ship = SHIPS[shipKey];
        let cdr = user.cards[shipKey] >= REQ_MAX ? 0.8 : 1.0;
        player.cooldowns[slot] = ship.cd * cdr; player.active[slot] = ship.dur;
        if(ship.name === "Dasher") { player.x += Math.cos(player.angle)*400; player.y += Math.sin(player.angle)*400; spawnParticle(player.x, player.y, 'yellow', 20); }
        if(ship.name === "Vision") { bots.forEach(b=>{ if(Math.hypot(b.x-player.x, b.y-player.y)<800){ b.vx=0; b.vy=0; b.angle+=Math.PI; }}); spawnParticle(player.x, player.y, 'magenta', 30); }
    }

    function switchShipInGame(key) {
        if(player.isSlingshot || player.isHyperspeed) return;
        if(user.cards[key] < REQ_UNLOCK) { addChat("System", "Ship Locked!", false); return; }
        user.slots.q = key; saveUser(); updateShipSwitcherUI(); addChat("System", "Switched to " + SHIPS[key].name, true); spawnParticle(player.x, player.y, '#ffffff', 20);
    }
    function updateShipSwitcherUI() {
        document.querySelectorAll('.switch-btn').forEach(btn => btn.classList.remove('active'));
        let current = user.slots.q; if(current) { let el = document.getElementById('switch-'+current); if(el) el.classList.add('active'); }
        for(let k in SHIPS) {
            let el = document.getElementById('switch-'+k);
            if(user.cards[k] < REQ_UNLOCK) { el.style.opacity = '0.3'; el.style.borderColor = 'red'; } else { el.style.opacity = '1'; el.style.borderColor = '#444'; }
        }
    }

    function setupRace() {
        gameState = 'race'; showMenu(null);
        document.getElementById('hud-layer').style.display='block'; document.getElementById('raceInfo').style.display='block'; document.getElementById('buildToolbar').style.display='none'; document.getElementById('chatContainer').style.display='none'; shipSwitcherEl.style.display = 'none';
        track = [{x:0,y:0}, {x:2000,y:-500}, {x:2000,y:2000}, {x:-500,y:2000}];
        player = { x:0, y:0, vx:0, vy:0, angle:0, cooldowns:{q:0, r:0}, active:{q:0, r:0}, lap:1, nextCheck:1, finished:false, wormholeDelay:0, friction:0.96, isSlingshot:false, isHyperspeed:false, slingCooldown:0 };
        bots = [{ x:0, y:100, vx:0, vy:0, angle:0, speed:0.95, nextCheck:1, lap:1, color:'#ff4444' }, { x:0, y:-100, vx:0, vy:0, angle:0, speed:0.92, nextCheck:1, lap:1, color:'#44ff44' }, { x:0, y:200, vx:0, vy:0, angle:0, speed:0.98, nextCheck:1, lap:1, color:'#ffff00' }];
        walls = []; planets = []; meteors = []; wormholes = [];
        createWallBox(-500, -1000, 3000, 3500); createWallBox(500, 0, 1000, 1500); waypoint = track[1];
    }

    function setupOpenWorld() {
        gameState = 'openworld'; showMenu(null);
        document.getElementById('hud-layer').style.display='block'; document.getElementById('raceInfo').style.display='none'; document.getElementById('buildToolbar').style.display='block'; document.getElementById('chatContainer').style.display='block'; shipSwitcherEl.style.display = 'flex'; updateShipSwitcherUI();
        player = { x:0, y:0, vx:0, vy:0, angle:0, cooldowns:{q:0, r:0}, active:{q:0, r:0}, lap:0, nextCheck:0, finished:false, wormholeDelay:0, friction:0.96, isSlingshot:false, isHyperspeed:false, slingCooldown:0 };
        walls = []; bots = []; waypoint = null;
        generateOpenWorld(); 
        if(socket) socket.emit('joinOpenWorld');
    }

    function generateOpenWorld() {
        planets = []; meteors = []; wormholes = [];
        for(let i=0; i<NUM_PLANETS; i++) {
            planets.push({
                x: (Math.random()-0.5) * (MAP_SIZE*2),
                y: (Math.random()-0.5) * (MAP_SIZE*2),
                r: 80 + Math.random() * 100
            });
        }
        for(let i=0; i<NUM_METEORS; i++) {
            meteors.push({
                x: (Math.random()-0.5) * (MAP_SIZE*2),
                y: (Math.random()-0.5) * (MAP_SIZE*2),
                vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3,
                s: 40+Math.random()*40, angle:Math.random(), spin:(Math.random()-0.5)*0.05
            });
        }
        for(let i=0; i<NUM_WORMHOLES; i++) {
            let x1 = (Math.random()-0.5)*(MAP_SIZE*1.5);
            let y1 = (Math.random()-0.5)*(MAP_SIZE*1.5);
            let x2 = (Math.random()-0.5)*(MAP_SIZE*1.5);
            let y2 = (Math.random()-0.5)*(MAP_SIZE*1.5);
            wormholes.push({ x:x1, y:y1, tx:x2, ty:y2, color: Math.random()>0.5?'cyan':'orange' });
        }
    }

    function updateRaceLogic() {
        if(player.finished) return;
        let dx = waypoint.x - player.x, dy = waypoint.y - player.y;
        if(Math.hypot(dx, dy) < 200) {
            player.nextCheck++;
            if(player.nextCheck >= track.length) { player.nextCheck = 0; player.lap++; document.getElementById('lapDisplay').innerText = player.lap + "/3"; if(player.lap > 3) finishRace(); }
            waypoint = track[player.nextCheck];
        }
        bots.forEach(b => {
            let bdx = track[b.nextCheck].x - b.x, bdy = track[b.nextCheck].y - b.y;
            let bang = Math.atan2(bdy, bdx);
            let da = bang - b.angle;
            if(da > Math.PI) da -= Math.PI*2; if(da < -Math.PI) da += Math.PI*2;
            b.angle += da * 0.1;
            b.vx += Math.cos(b.angle)*b.speed; b.vy += Math.sin(b.angle)*b.speed;
            b.vx *= 0.96; b.vy *= 0.96; b.x += b.vx; b.y += b.vy;
            if(Math.hypot(bdx, bdy) < 200) { b.nextCheck++; if(b.nextCheck >= track.length) { b.nextCheck=0; b.lap++; } }
        });
        bots.sort((a,b) => (b.lap*1000 + b.nextCheck*100) - (a.lap*1000 + a.nextCheck*100));
        let pScore = player.lap*1000 + player.nextCheck*100;
        let rank = 1; bots.forEach(b => { if((b.lap*1000+b.nextCheck*100) > pScore) rank++; });
        document.getElementById('posDisplay').innerText = rank + "/" + (bots.length+1);
    }

    function drawWorld() {
        ctx.fillStyle = '#050508'; ctx.fillRect(0,0,width,height);
        ctx.save(); ctx.translate(-camera.x, -camera.y);
        ctx.strokeStyle = '#222'; ctx.lineWidth = 2;
        let g=500, sx=Math.floor(camera.x/g)*g, sy=Math.floor(camera.y/g)*g;
        ctx.beginPath();
        for(let x=sx; x<camera.x+width; x+=g) { ctx.moveTo(x,camera.y); ctx.lineTo(x,camera.y+height); }
        for(let y=sy; y<camera.y+height; y+=g) { ctx.moveTo(camera.x,y); ctx.lineTo(camera.x+width,y); }
        ctx.stroke();

        planets.forEach(p => { 
            ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill(); 
            ctx.strokeStyle = '#bf00ff'; ctx.lineWidth=5; ctx.stroke(); 
            ctx.beginPath(); ctx.arc(p.x, p.y, p.r + 250, 0, Math.PI*2); ctx.strokeStyle = 'rgba(191, 0, 255, 0.2)'; ctx.lineWidth=2; ctx.stroke();
        });
        wormholes.forEach(w => { ctx.save(); ctx.translate(w.x, w.y); ctx.rotate(Date.now()/500); ctx.strokeStyle = w.color; ctx.lineWidth=4; ctx.beginPath(); for(let i=0; i<3; i++) { ctx.arc(0,0, 30-i*5, i, Math.PI+i); } ctx.stroke(); ctx.restore(); });
        ctx.fillStyle = '#654321'; meteors.forEach(m => { ctx.save(); ctx.translate(m.x, m.y); ctx.rotate(m.angle); ctx.beginPath(); ctx.arc(0,0, m.s, 0, Math.PI*2); ctx.fill(); ctx.restore(); });

        ctx.fillStyle = '#555'; ctx.strokeStyle = '#888'; ctx.lineWidth = 2;
        walls.forEach(w => { ctx.save(); ctx.translate(w.x, w.y); ctx.rotate(w.angle); ctx.fillRect(-w.w/2, -w.h/2, w.w, w.h); ctx.strokeRect(-w.w/2, -w.h/2, w.w, w.h); ctx.restore(); });

        if(waypoint && gameState === 'race') { ctx.strokeStyle = '#00ff00'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(waypoint.x, waypoint.y, 200, 0, Math.PI*2); ctx.stroke(); }
        
        bots.forEach(b => drawShip(b.x, b.y, b.angle, b.color, false));
        drawShip(player.x, player.y, player.angle, SHIPS[user.slots.q]?.color||'#fff', true);
        
        // Particle Logic including Warp Lines
        particles.forEach(p => { 
            ctx.fillStyle = p.c; 
            if(p.life) { // Warp line logic
                ctx.save(); ctx.translate(p.x, p.y); 
                let angle = Math.atan2(p.vy, p.vx); ctx.rotate(angle);
                ctx.fillRect(0, -1, Math.hypot(p.vx, p.vy)*2, 2); 
                ctx.restore();
            } else {
                ctx.beginPath(); ctx.arc(p.x, p.y, p.s, 0, Math.PI*2); ctx.fill(); 
            }
        });
        
        ctx.restore();
        drawMiniMap(mmCtx, 180, 180);
        if(document.getElementById('bigMapOverlay').style.display === 'block') drawMiniMap(bmCtx, bmCanvas.width, bmCanvas.height);
    }

    function drawShip(x, y, ang, color, isSelf) {
        ctx.save(); ctx.translate(x, y); ctx.rotate(ang);
        if(isSelf && (player.active.q>0 && SHIPS[user.slots.q].name==='Shadow' || player.active.r>0 && SHIPS[user.slots.r].name==='Shadow')) ctx.globalAlpha = 0.5;
        ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(20,0); ctx.lineTo(-15, 15); ctx.lineTo(-5,0); ctx.lineTo(-15,-15); ctx.fill();
        ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(-2,0,5,0,Math.PI*2); ctx.fill();
        ctx.restore();
    }
    
    function drawMiniMap(c, w, h) { 
        c.fillStyle = '#000'; c.fillRect(0,0,w,h); 
        // Dynamic scale for Minimap if moving super fast? No, keep it stable so they see how fast they are moving relative to map
        let viewScale = w === 180 ? 0.02 : (w / (MAP_SIZE*2)); 
        let cx = w/2, cy = h/2;
        let offsetX = w === 180 ? -player.x * viewScale : 0;
        let offsetY = w === 180 ? -player.y * viewScale : 0;

        planets.forEach(p => {
            let px = p.x * viewScale + cx + offsetX;
            let py = p.y * viewScale + cy + offsetY;
            c.fillStyle = '#bf00ff'; c.beginPath(); c.arc(px, py, 4, 0, Math.PI*2); c.fill();
        });
        wormholes.forEach(wm => {
            let wx = wm.x * viewScale + cx + offsetX;
            let wy = wm.y * viewScale + cy + offsetY;
            c.fillStyle = 'cyan'; c.beginPath(); c.arc(wx, wy, 3, 0, Math.PI*2); c.fill();
        });
        if(w > 200) {
            c.fillStyle = '#654321';
            meteors.forEach(m => {
                let mx = m.x * viewScale + cx + offsetX;
                let my = m.y * viewScale + cy + offsetY;
                c.fillRect(mx-1, my-1, 2, 2);
            });
        }
        let px = player.x * viewScale + cx + offsetX;
        let py = player.y * viewScale + cy + offsetY;
        if(w === 180) { px = cx; py = cy; }
        c.fillStyle = '#0f0'; c.beginPath(); c.arc(px,py,3,0,Math.PI*2); c.fill(); 
    }
    
    function drawHUD() { 
        let s = Math.hypot(player.vx, player.vy)*10;
        let displaySpeed = Math.round(s);
        // Scientific notation or "MAX" for insane speeds
        if(displaySpeed > 999999) displaySpeed = "INF";
        document.getElementById('speedDisplay').innerText = displaySpeed; 
        document.getElementById('hudPoints').innerText = user.points; 
        updateSlotUI('q'); updateSlotUI('r'); 
    }
    function updateSlotUI(slot) {
        let key = user.slots[slot];
        let nameEl = document.getElementById('name-'+slot), statEl = document.getElementById('status-'+slot);
        if(slot === 'r' && !user.slotRUnlocked) { nameEl.innerText = "LOCKED"; statEl.innerText = ""; statEl.className="locked-slot"; return; }
        if(!key) { nameEl.innerText = "--"; statEl.innerText = "EMPTY"; statEl.className = "ready"; return; }
        nameEl.innerText = SHIPS[key].name.toUpperCase();
        if(user.cards[key] >= REQ_MAX) nameEl.classList.add('mastered-hud'); else nameEl.classList.remove('mastered-hud');
        let cd = player.cooldowns[slot];
        if(cd > 0) { statEl.innerText = Math.ceil(cd/60) + "s"; statEl.className = "cooldown"; } else { statEl.innerText = "READY"; statEl.className = "ready"; }
    }

    let selectedHangarShip = null;
    function openHangar() { showMenu('hangarMenu'); renderHangar(); }
    function renderHangar() {
        document.getElementById('hangarPoints').innerText = user.points; document.getElementById('hangarTokens').innerText = user.mergeTokens;
        const c = document.getElementById('cardContainer'); c.innerHTML = "";
        for(let key in SHIPS) {
            let s = SHIPS[key]; let count = user.cards[key]; let unlocked = count >= REQ_UNLOCK; let mastered = count >= REQ_MAX;
            let div = document.createElement('div'); div.className = "ship-card " + (mastered ? "mastered" : (unlocked ? "unlocked" : ""));
            if(selectedHangarShip === key) div.classList.add('selected');
            let barColor = mastered ? "#ffd700" : (unlocked ? '#00d2ff' : '#ff4444');
            let pct = mastered ? 100 : (unlocked ? (count/REQ_MAX)*100 : (count/REQ_UNLOCK)*100);
            div.innerHTML = `<div style="font-size:10px; color:${s.color}; padding:5px;">${mastered?"MASTERED!":(unlocked?"UNLOCKED":"LOCKED")}</div><div class="card-bar-bg"><div class="card-fill" style="width:${pct}%; background:${barColor}"></div></div><div class="card-name" style="color:${s.color}">${s.name}</div><div style="font-size:10px; color:#aaa;">${count}/${unlocked ? REQ_MAX : REQ_UNLOCK}</div>`;
            if(count > 0) div.innerHTML += `<button class="red" onclick="event.stopPropagation(); sellCard('${key}')">Sell (10pts)</button>`;
            div.onclick = () => { selectedHangarShip = key; renderHangar(); }; c.appendChild(div);
        }
        let q = user.slots.q ? SHIPS[user.slots.q] : null; document.getElementById('slotQ').innerHTML = q ? `<span style="color:${q.color}">${q.name}</span>` : "[Q] Empty";
        let rContainer = document.getElementById('slotR_Container');
        if(user.slotRUnlocked) { let r = user.slots.r ? SHIPS[user.slots.r] : null; rContainer.innerHTML = `<div id="slotR" onclick="equipTo('r')" style="border:1px dashed #555; width:120px; height:80px; display:flex; align-items:center; justify-content:center; cursor:pointer;">${r ? `<span style="color:${r.color}">${r.name}</span>` : "[R] Empty"}</div>`; } 
        else { rContainer.innerHTML = `<button class="purple" onclick="unlockSecondary()">Unlock Slot R<br>(50 Tokens)</button>`; }
    }
    function sellCard(key) { if(user.cards[key] > 0) { user.cards[key]--; user.points += 10; saveUser(); renderHangar(); } }
    function unlockSecondary() { if(user.mergeTokens >= 50) { user.mergeTokens -= 50; user.slotRUnlocked = true; saveUser(); renderHangar(); } else { alert("Not enough Merge Tokens!"); } }
    function equipTo(slot) { if(!selectedHangarShip) return alert("Select a card!"); if(user.cards[selectedHangarShip] < REQ_UNLOCK) return alert(`LOCKED!`); user.slots[slot] = selectedHangarShip; saveUser(); renderHangar(); updateShipSwitcherUI(); }
    function buyBox() {
        if(user.points < 1000) return alert("Need 1000 Points!"); user.points -= 1000;
        let roll = Math.random() * 100; let drops = []; let msg = ""; let keys = Object.keys(SHIPS);
        if(roll < 50) { let pts = Math.floor(Math.random() * 300) + 200; user.points += pts; msg = `+${pts} POINTS!`; } 
        else if (roll < 80) { let k = keys[Math.floor(Math.random()*keys.length)]; user.cards[k]++; drops.push(SHIPS[k]); msg = "1 CARD!"; } 
        else if (roll < 90) { for(let i=0; i<2; i++) { let k = keys[Math.floor(Math.random()*keys.length)]; user.cards[k]++; drops.push(SHIPS[k]); } msg = "2 CARDS!"; } 
        else if (roll < 94) { keys.forEach(k => { user.cards[k]++; drops.push(SHIPS[k]); }); msg = "FULL SET!"; } 
        else { user.points += 10000; msg = "JACKPOT! 10,000 PTS!"; }
        saveUser(); renderHangar();
        document.getElementById('lootOverlay').style.display = 'flex'; document.getElementById('lootResults').innerHTML = ""; document.getElementById('lootMsg').innerText = ""; document.getElementById('lootClose').style.display = 'none';
        setTimeout(() => { document.getElementById('lootText').innerText = "OPENED!"; document.getElementById('lootMsg').innerText = msg; document.getElementById('lootBoxVisual').style.animation = "none"; drops.forEach((d) => { let card = document.createElement('div'); card.className = "ship-card unlocked"; card.innerHTML = `<div style="padding:10px; color:${d.color}; font-weight:bold;">${d.name}</div>`; document.getElementById('lootResults').appendChild(card); }); document.getElementById('lootClose').style.display = 'block'; }, 1500);
    }
    function closeLoot() { document.getElementById('lootOverlay').style.display = 'none'; document.getElementById('lootText').innerText = "OPENING..."; document.getElementById('lootBoxVisual').style.animation = "shake 0.5s infinite"; }
    function saveAndExitHangar() { saveUser(); showMenu('mainMenu'); }
    function showMenu(id) { document.querySelectorAll('.menu-box').forEach(m => m.classList.remove('visible')); if(id) document.getElementById(id).classList.add('visible'); }
    function spawnParticle(x,y,c,n) { for(let i=0;i<n;i++) particles.push({x:x,y:y,vx:(Math.random()-0.5)*10,vy:(Math.random()-0.5)*10,s:Math.random()*3+1,c:c}); }
    function updateParticles() { for(let i=particles.length-1; i>=0; i--) { particles[i].x+=particles[i].vx; particles[i].y+=particles[i].vy; if(particles[i].life) { particles[i].life--; if(particles[i].life<=0) particles.splice(i,1); continue; } particles[i].s*=0.9; if(particles[i].s<0.5) particles.splice(i,1); } }
    function toggleBigMap() { let el = document.getElementById('bigMapOverlay'); el.style.display = el.style.display === 'block' ? 'none' : 'block'; }
    function createWallBox(x,y,w,h) { walls.push({x:x+w/2,y:y,w:w,h:20,angle:0}); walls.push({x:x+w/2,y:y+h,w:w,h:20,angle:0}); walls.push({x:x,y:y+h/2,w:h,h:20,angle:Math.PI/2}); walls.push({x:x+w,y:y+h/2,w:h,h:20,angle:Math.PI/2}); }
    function setBuildTool(n) { buildTool=n; document.querySelectorAll('.tool-btn').forEach((b,i)=>b.classList.toggle('active',i===n)); }
    function finishRace() { player.finished = true; let rank = 1; bots.forEach(b => { if(b.lap > 3) rank++; }); let reward = rank===1?500 : (rank===2?300:100); user.points += reward; if(rank === 1) { user.mergeTokens++; document.getElementById('tokenReward').style.display = 'block'; } else { document.getElementById('tokenReward').style.display = 'none'; } saveUser(); document.getElementById('finishRank').innerText = rank + (rank===1?"st":rank===2?"nd":rank===3?"rd":"th") + " Place"; document.getElementById('finishPoints').innerText = reward; showMenu('finishMenu'); }
    
    updateShipSwitcherUI();
</script>
</body>
</html>
